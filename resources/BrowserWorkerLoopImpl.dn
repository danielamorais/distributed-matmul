// Browser Worker ProcessLoop Implementation
// This runs continuously in Dana's WASM runtime
// HTTP requests MUST be made from async context, not from loop() directly

uses net.http.Header

component provides BrowserWorkerLoop requires io.Output out, data.IntUtil iu, 
    data.json.JSONEncoder je, data.json.JSONParser jp, data.StringUtil su,
    net.http.HTTPRequest http, time.Timer timer, matmul.Matmul matmul {
    
    const char COORDINATOR_URL[] = "http://localhost:8080/task/next"
    const char RESULT_URL_PREFIX[] = "http://localhost:8080/task/"
    const char RESULT_URL_SUFFIX[] = "/result"
    const int POLL_INTERVAL_LOOPS = 200 // Approximate loops for 2 seconds (assuming ~10ms per loop)
    
    char workerId[] = null
    int tasksCompleted = 0
    int loopCount = 0
    int lastPollLoop = 0
    
    // HTTP request state (for async operations)
    HTTPResponse currentResponse = null
    bool waitingForResponse = false
    int currentTaskId = 0
    char currentResult[] = null
    int requestType = 0 // 0=none, 1=poll, 2=submit
    
    BrowserWorkerLoop:BrowserWorkerLoop() {
        // Generate worker ID on initialization using loop count
        workerId = new char[]("worker-wasm-", iu.makeString(loopCount))
        out.println("[@BrowserWorkerWASM] Worker ID: $(workerId)")
    }
    
    // This function is called repeatedly by Dana's WASM runtime
    // It MUST NOT block and should return quickly
    bool BrowserWorkerLoop:loop() {
        loopCount++
        
        // Check if we're waiting for an HTTP response
        if (waitingForResponse) {
            if (currentResponse != null) {
                handleResponse()
                waitingForResponse = false
                currentResponse = null
            }
            // Still waiting, return true to continue loop
            return true
        }
        
        // Time to poll for new task?
        if (loopCount - lastPollLoop >= POLL_INTERVAL_LOOPS) {
            lastPollLoop = loopCount
            startPollRequest()
        }
        
        // Continue running
        return true
    }
    
    void startPollRequest() {
        if (waitingForResponse) return // Already have a request in flight
        
        out.println("[@BrowserWorkerWASM] Polling for tasks...")
        
        // Build poll URL with worker ID
        char pollUrl[] = new char[](COORDINATOR_URL, "?workerId=", workerId)
        
        // Build headers
        Header headers[] = new Header[](
            new Header("Content-Type", "application/json")
        )
        
        // Start async request
        // IMPORTANT: HTTPRequest cannot be used from ProcessLoop:loop() directly
        // Must call from async context using asynch::
        requestType = 1 // poll request
        waitingForResponse = true
        
        // Execute HTTP request in async context
        asynch::executePollRequest(pollUrl, headers)
    }
    
    void executePollRequest(char url[], Header headers[]) {
        // This runs in async context, allowing HTTP requests in WASM
        // http.get() must be called from async context, not from ProcessLoop:loop()
        currentResponse = http.get(url, headers, false)
    }
    
    void handleResponse() {
        if (currentResponse == null) return
        
        if (requestType == 1) {
            // Handle poll response
            handlePollResponse()
        } else if (requestType == 2) {
            // Handle submit response
            handleSubmitResponse()
        }
        
        requestType = 0
    }
    
    void handlePollResponse() {
        if (currentResponse == null) {
            out.println("[@BrowserWorkerWASM] No response from coordinator")
            return
        }
        
        if (currentResponse.responseCode == "204") {
            // No tasks available - this is normal
            return
        }
        
        if (currentResponse.responseCode != "200") {
            out.println("[@BrowserWorkerWASM] Error response: $(currentResponse.responseCode)")
            return
        }
        
        // Convert byte[] content to char[] for JSON parsing
        if (currentResponse.content == null || currentResponse.content.arrayLength == 0) {
            out.println("[@BrowserWorkerWASM] Empty response body")
            return
        }
        
        char responseBody[] = new char[currentResponse.content.arrayLength]
        for (int i = 0; i < currentResponse.content.arrayLength; i++) {
            responseBody[i] = currentResponse.content[i]
        }
        
        // Parse JSON task - server sends {taskId, data: {A, B}}
        // Parse the nested structure manually
        JSONElement root = jp.parseDocument(responseBody)
        if (root == null) {
            out.println("[@BrowserWorkerWASM] Failed to parse task response")
            return
        }
        
        // Extract taskId
        JSONElement taskIdElem = jp.getValue(root, "taskId")
        if (taskIdElem == null || taskIdElem.type != JSONElement.TYPE_NUMBER) {
            out.println("[@BrowserWorkerWASM] Missing or invalid taskId")
            return
        }
        int taskId = iu.intFromString(taskIdElem.value)
        
        // Extract data object
        JSONElement dataElem = jp.getValue(root, "data")
        if (dataElem == null || dataElem.type != JSONElement.TYPE_OBJECT) {
            out.println("[@BrowserWorkerWASM] Missing or invalid data field")
            return
        }
        
        // Extract A and B from data object
        JSONElement aElem = jp.getValue(dataElem, "A")
        JSONElement bElem = jp.getValue(dataElem, "B")
        
        if (aElem == null || bElem == null || 
            aElem.type != JSONElement.TYPE_STRING || bElem.type != JSONElement.TYPE_STRING) {
            out.println("[@BrowserWorkerWASM] Missing or invalid A/B fields")
            return
        }
        
        char dataA[] = aElem.value
        char dataB[] = bElem.value
        
        out.println("[@BrowserWorkerWASM] Received task #$(iu.makeString(taskId))")
        
        // Compute result (this is synchronous and local - no HTTP needed)
        char result[] = computeTask(taskId, dataA, dataB)
        
        if (result == null) {
            out.println("[@BrowserWorkerWASM] Computation failed")
            return
        }
        
        // Start submit request
        currentTaskId = taskId
        currentResult = result
        startSubmitRequest(taskId, result)
    }
    
    void handleSubmitResponse() {
        if (currentResponse == null || currentResponse.responseCode != "200") {
            out.println("[@BrowserWorkerWASM] Failed to submit result for task #$(iu.makeString(currentTaskId))")
            return
        }
        
        tasksCompleted++
        out.println("[@BrowserWorkerWASM] Task #$(iu.makeString(currentTaskId)) completed successfully!")
        out.println("[@BrowserWorkerWASM] Total tasks completed: $(iu.makeString(tasksCompleted))")
    }
    
    char[] computeTask(int taskId, char dataA[], char dataB[]) {
        if (dataA == null || dataB == null) {
            out.println("[@BrowserWorkerWASM] Missing matrix data")
            return null
        }
        
        out.println("[@BrowserWorkerWASM] Computing: A=$(dataA), B=$(dataB)")
        
        // Parse matrices
        Matrix A = matmul.charToMatrix(dataA)
        Matrix B = matmul.charToMatrix(dataB)
        
        if (A == null || B == null) {
            out.println("[@BrowserWorkerWASM] Failed to parse matrices")
            return null
        }
        
        // Multiply (pure Dana computation)
        Matrix result = matmul.multiply(A, B)
        
        if (result == null) {
            out.println("[@BrowserWorkerWASM] Multiplication failed")
            return null
        }
        
        // Convert back to string
        char resultStr[] = matmul.matrixToChar(result)
        out.println("[@BrowserWorkerWASM] Computation complete: $(resultStr)")
        
        return resultStr
    }
    
    void startSubmitRequest(int taskId, char result[]) {
        if (waitingForResponse) return // Already have a request in flight
        
        out.println("[@BrowserWorkerWASM] Submitting result for task #$(iu.makeString(taskId))")
        
        // Build result URL
        char resultUrl[] = new char[](RESULT_URL_PREFIX, iu.makeString(taskId), RESULT_URL_SUFFIX)
        
        // Build JSON body - create a data structure for JSON encoding
        ResultData resultData = new ResultData()
        resultData.result = result
        char jsonBody[] = je.jsonFromData(resultData)
        
        // Build headers
        Header headers[] = new Header[](
            new Header("Content-Type", "application/json")
        )
        
        // Start async request
        requestType = 2 // submit request
        waitingForResponse = true
        
        // Execute HTTP request in async context
        asynch::executeSubmitRequest(resultUrl, headers, jsonBody)
    }
    
    void executeSubmitRequest(char url[], Header headers[], char postData[]) {
        // This runs in async context, allowing HTTP requests in WASM
        // http.post() must be called from async context, not from ProcessLoop:loop()
        currentResponse = http.post(url, headers, postData, false)
    }
}

// Data structures
data ResultData {
    char result[]
}
