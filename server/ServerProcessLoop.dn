uses server.Server

const int LOOP_SLEEP_MS = 1

data RequestBuffer {
    char payload[]
}

data ResponseBuffer {
    char payload[]
}

component provides server.ServerProcessLoop requires io.Output out, time.Timer timer, server.Server server {
    RequestBuffer requestQueue[]
    ResponseBuffer responseQueue[]
    Mutex requestLock = new Mutex()
    Mutex responseLock = new Mutex()
    bool configured = false

    void ServerProcessLoop:configure(int startMode) {
        server.initialize(startMode)
        configured = true
    }

    void ServerProcessLoop:enqueueRequest(char requestBuffer[]) {
        char payload[] = clone requestBuffer
        mutex(requestLock) {
            requestQueue = new RequestBuffer[](requestQueue, new RequestBuffer(payload))
        }
    }

    bool ServerProcessLoop:hasPendingResponse() {
        mutex(responseLock) {
            return responseQueue != null && responseQueue.arrayLength > 0
        }
    }

    char[] ServerProcessLoop:nextResponse() {
        mutex(responseLock) {
            if(responseQueue == null || responseQueue.arrayLength == 0) return null
            ResponseBuffer entry = responseQueue[0]
            responseQueue = rebuildResponseQueue(responseQueue, 0)
            return entry.payload
        }
    }

    bool ServerProcessLoop:loop() {
        if(!configured) {
            timer.sleep(LOOP_SLEEP_MS)
            return true
        }

        char httpRequest[] = takeNextRequest()
        if(httpRequest != null) {
            char response[] = server.handleRequest(httpRequest)
            if(response != null && response.arrayLength > 0) {
                mutex(responseLock) {
                    responseQueue = new ResponseBuffer[](responseQueue, new ResponseBuffer(response))
                }
            }
        } else {
            timer.sleep(LOOP_SLEEP_MS)
        }

        return true
    }

    char[] takeNextRequest() {
        mutex(requestLock) {
            if(requestQueue == null || requestQueue.arrayLength == 0) return null
            RequestBuffer entry = requestQueue[0]
            requestQueue = rebuildRequestQueue(requestQueue, 0)
            return entry.payload
        }
    }

    RequestBuffer[] rebuildRequestQueue(RequestBuffer queue[], int skipIndex) {
        RequestBuffer result[] = null
        for(int i = 0; i < queue.arrayLength; i++) {
            if(i != skipIndex) {
                result = new RequestBuffer[](result, queue[i])
            }
        }
        return result
    }

    ResponseBuffer[] rebuildResponseQueue(ResponseBuffer queue[], int skipIndex) {
        ResponseBuffer result[] = null
        for(int i = 0; i < queue.arrayLength; i++) {
            if(i != skipIndex) {
                result = new ResponseBuffer[](result, queue[i])
            }
        }
        return result
    }
}


