---
alwaysApply: true
---
Dana uses strict encapsulation between components to support sound runtime adaptation. As part of this encapsulation, data and array instances that are passed between components are read-only (or immutable) at any component which did not create the instance.
Overview

Consider the below example, which creates an array of data instances and then asks for that array to be sorted by one of its fields:

data Person {
	char firstname[]
	char surname[]
	int age
}

component provides App requires io.Output out, data.query.Sort sort {

	int App:main(AppParam params[]) {
		Person people[] = new Person[](new Person("Alex", "Smith", 19),
										new Person("Faiza", "Nihiri", 27),
										new Person("Sula", "Kerridge", 23))

		people = sort.sort(people, Person.[surname], true)
		
		return 0
		}
	
}

When we pass our people array into sort(), we are passing that array reference to another component. The sort() function is therefore unable to write to the cells of that array, and must gain write-ownership of the array. This is done by using the clone operator. When the sort() function returns the sorted array back to our main function, this version of the array is then read-only to our own component.

If we try to modify a cell of that array after the sort() call we get a run-time error:

people = sort.sort(people, Person.[surname], true)
people[1] = new Person("Penelope", "Eve", 48)

Exception::attempt to assign to read-only location on line 15 of Test.dn

We can use the clone operator to regain write-ownership of the returned array to remove the exception:

people = clone sort.sort(people, Person.[surname], true)
people[1] = new Person("Penelope", "Eve", 48)

Clone details

The clone operator makes a copy of the instance it is given, whether this is an array or a data instance. By creating a copy, this gives the caller write-ownership of the respective instance. The copy has all of the same field values of the original, such that if any of those fields refer to other array or data instances, those referenced instances are not themselves copied.

To perform a recursive copy you may use the rclone operator, but note that this is very rarely needed and may be expensive on large data structures.

In some cases the compiler and runtime can determine from the surrounding context that it is not necessary to actually copy the instance given to clone, and in this case the instance is simply given a change of write-ownership.