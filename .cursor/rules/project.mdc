---
alwaysApply: true
---
# Distributed Matrix Multiplication Research Project

## Project Overview
This is a research project implementing **distributed matrix multiplication** with runtime adaptation using the Dana programming language. It serves as a toy application for testing proxy approaches to runtime adaptation.

## Core Functionality
- **Matrix Multiplication**: The main computation is matrix multiplication (`matmul/Matmul.dn`)
- **HTTP API**: Accepts matrix multiplication requests via HTTP POST to `/matmul`
- **Runtime Adaptation**: Can switch between local/serial computation and distributed computation based on performance
- **Proxy Pattern**: Uses generated proxy files (`.proxy.dn`) for runtime component adaptation

## Key Components

### Server Architecture
- `server/Server.dn`: Main server that handles HTTP requests and manages adaptation
- `app/RemoteRepo.dn`: Remote worker components for distributed computation
- `server/MatmulController.dn`: Handles matrix multiplication requests
- `matmul/Matmul.dn`: Core matrix multiplication logic
- `matmul/Matmul.proxy.dn`: Auto-generated proxy for runtime adaptation

### Adaptation Modes
The system supports three operational modes:
1. **Serial mode** (option 3): Local computation only
2. **Proxy mode** (option 1): Starts with proxy/distributed setup
3. **Adaptive mode** (option 2): Dynamically adapts based on response time thresholds

### Testing Infrastructure
- `testing/locustfile.py`: Load testing with Locust
- `testing/mininet_network*.py`: Network simulation with multiple remote nodes
- `testing/locustfile_serial.py`: Serial baseline testing
- Results stored in `results/` with CSV files and plotting scripts

## Development Workflow

### Building
- Use `dnc .` to compile Dana files
- WASM compilation: `compile-wasm.sh` and `package-wasm.sh`
- Docker: Separate containers for main and remote components

### Running
- Main app: `dana main.o [mode]` where mode is 1 (proxy), 2 (adapt), or 3 (serial)
- Remote workers: `dana RemoteRepo.o [port] [app_port]`
- Docker: `docker-compose up` to start all services

### Proxy Generator
Python tool (`proxy_generator/`) that generates `.proxy.dn` files from `.dn` source files for runtime adaptation support. The generated proxy:
- Implements the same interface as the original component (here `matmul.Matmul`)
- Implements `AdaptEvents` interface for adaptation lifecycle callbacks (`active()` and `inactive()`)
- Routes calls to remote worker nodes via RPC
- Handles data serialization/deserialization for network communication

## Key Files
- Dana source files use `.dn` extension
- Interface files live in `resources/` subdirectories (e.g., `resources/matmul/`)
- Component implementations live in the project root (e.g., `matmul/Matmul.dn`, `server/Server.dn`)
- Proxy generator creates `.proxy.dn` files in the same directory as the original component
- Compiled output uses `.o` extension (e.g., `Matmul.o`, `Server.o`)
- Testing infrastructure in Python
- Results include performance comparisons (distributed vs serial)
- Matrix operations handle integer matrices with JSON serialization

## Dana Conventions Used
- **Async execution**: Uses `asynch::` prefix for non-blocking function calls (e.g., `asynch::handleRequest(client)`)
- **Package naming**: Components declare package via directory structure (e.g., `server.Server`, `matmul.Matmul`)
- **Interface instantiation**: Required interfaces with no constructor get auto-instantiated as globals (e.g., `io.Output out`)
- **Interface instantiation**: Required interfaces with constructors must be manually instantiated (e.g., `net.TCPSocket`)
- **Mutex synchronization**: Uses `mutex(lock)` blocks for thread-safe access

## Important Context
- This is a **research project** for testing distributed computing patterns
- Focus on runtime adaptation and proxy-based component switching
- Performance testing compares distributed vs serial computation approaches
- Written in Dana language (component-based language)
- Architecture supports scaling to multiple remote worker nodes

## Dana-Specific Implementation Details

### Runtime Adaptation Mechanics
- Uses `composition.RecursiveLoader` to dynamically load components (`matmul/Matmul.o`, `matmul/Matmul.proxy.o`)
- Uses `composition.Adapt.adaptRequiredInterface()` to switch between implementations at runtime
- Components are wired using `wire()` to connect required interfaces to provided interfaces
- Objects are instantiated using `new Type() from ComponentIDC` pattern

### Component Loading
```dana
LoadedComponents matmul = loader.load("matmul/Matmul.o")
LoadedComponents matmulProxy = loader.load("matmul/Matmul.proxy.o")
```

### Adaptation Callbacks
Generated proxies implement `AdaptEvents` interface (secondary interface):
- `AdaptEvents:active()` - Called when this component replaces another
- `AdaptEvents:inactive()` - Called when this component is being replaced

### Data Passing
- Matrices are serialized as JSON for network transmission
- Uses `data.json.JSONEncoder` and `data.json.JSONParser` for serialization
- Arrays become read-only when passed between components (Dana's encapsulation)

