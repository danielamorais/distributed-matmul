const char debugMSG[] = "[@HTTPUtil]"

component provides network.http.HTTPUtil requires io.Output out, data.IntUtil iu, io.FileSystem fileSystem, 
	data.StringUtil stringUtil {
    
    HTTPMessage HTTPUtil:readHTTPRequest(char buf[]) {
        // Find the end of headers (double CRLF)
        int headerEnd = 0
        for (int i = 0; i < buf.arrayLength - 3; i++) {
            if (buf[i] == "\r" && buf[i+1] == "\n" && buf[i+2] == "\r" && buf[i+3] == "\n") {
                headerEnd = i + 4
                break
            }
        }
        
        // Parse headers
        char headerBuf[] = null
        if (headerEnd > 0) {
            headerBuf = new char[headerEnd]
            for (int i = 0; i < headerEnd; i++) {
                headerBuf[i] = buf[i]
            }
        } else {
            headerBuf = buf
        }
        
        HTTPMessage httpMessage = parseHTTPRequest(headerBuf)
        httpMessage.rawHeader = headerBuf
        
        // Parse body if contentLength > 0
        if (headerEnd > 0 && headerEnd < buf.arrayLength && httpMessage.contentLength > 0) {
            int bodyStart = headerEnd
            int bodyLength = httpMessage.contentLength
            if (bodyStart + bodyLength <= buf.arrayLength) {
                httpMessage.postData = new char[bodyLength]
                for (int i = 0; i < bodyLength; i++) {
                    httpMessage.postData[i] = buf[bodyStart + i]
                }
            }
        }
        
        return httpMessage
    }
    
    char[] HTTPUtil:buildHTTPResponse(int code, char status[], char serverName[], int contentLength, char contentType[], char body[]) {
        char response[] = "HTTP/1.1 $(iu.makeString(code)) $status\r\n"
        response = new char[](response, "Server: $serverName\r\n")
        response = new char[](response, "Content-Length: $(iu.makeString(contentLength))\r\n")
        response = new char[](response, "Connection: close\r\n")
        response = new char[](response, "Content-Type: $contentType\r\n")
        response = new char[](response, "\r\n")
        if (body != null && body.arrayLength > 0) {
            response = new char[](response, body)
        }
        return response
    }

    // examples of request first line:
	// request: GET /path/to/file/index.html HTTP/1.0
	// response: HTTP/1.0 200 OK
	HTTPMessage HTTPUtil:parseHTTPRequest(char buf[]) {
		HTTPMessage httpMessage = new HTTPMessage()
		String lines[] = stringUtil.explode(buf, "\r\n")
		bool resp = false
		for (int lineCounter = 0; lineCounter < lines.arrayLength; lineCounter++) {
			String helper[] = stringUtil.explode(lines[lineCounter].string, " ")
			if (lineCounter == 0) {
				// HTTP header
				if ((helper[0].string == "HTTP/1.0") || (helper[0].string == "HTTP/1.1")) {
					// response
					httpMessage.version = helper[0].string
					if (stringUtil.isNumeric(helper[1].string)) {
						httpMessage.status = iu.intFromString(helper[1].string)	
					} else { throw new Exception ("Invalid HTTP format.") }
					helper = removeFromList(helper, 0)
					helper = removeFromList(helper, 0)
					httpMessage.reasonPhrase = stringUtil.implode(helper, " ")
					resp = true
				} else {
					// request
					httpMessage.command = helper[0].string
					httpMessage.resource = helper[1].string
					httpMessage.version = helper[2].string
					resp = false
				}
			} else {
				char aux[]
				// if: in case the client make a request and do not add a space after the colon
				if (helper.arrayLength == 1) {
					helper = stringUtil.explode(lines[lineCounter].string, ":")
					aux = new char[](stringUtil.lowercase(helper[0].string), ":")
				} else { aux = stringUtil.lowercase(helper[0].string) }
				helper = removeFromList(helper, 0)
				if (aux == "connection:") { httpMessage.connection = stringUtil.implode(helper, " ") }
				if (aux == "accept:") { httpMessage.accept = stringUtil.implode(helper, " ") }
				if (aux == "user-agent:") { httpMessage.userAgent = stringUtil.implode(helper, " ") }
				if (aux == "accept-encoding:") { httpMessage.acceptEncoding = stringUtil.implode(helper, " ") }
				if (aux == "accept-language:") { httpMessage.acceptLanguage = stringUtil.implode(helper, " ") }
				if (aux == "content-type:") { httpMessage.contentType = stringUtil.implode(helper, " ") }
				if (aux == "content-length:") {
					char cLength[] = helper[0].string
					if (stringUtil.isNumeric(cLength)) { httpMessage.contentLength = iu.intFromString(cLength) }
					else { throw new Exception("HTTP invalid package format.") }							
				}
				if (aux == "server:") { httpMessage.server = stringUtil.implode(helper, " ") }
				if (aux == "content-encoding:") { httpMessage.contentEnconding = stringUtil.implode(helper, " ") }
				if (aux == "access-control-allow-origin:") {
					httpMessage.accessControlAllowOrigin = stringUtil.implode(helper, " ")
				}
			}
		}
		if (!resp) {
			httpMessage.queryString = getQueryString(httpMessage.resource)
			httpMessage.resource = normalisePath(httpMessage.resource)
			httpMessage.resourceExists = resourceExists(httpMessage.resource)
			httpMessage.mimeType = getMIMEType(httpMessage.resource)	
		}
		return httpMessage
	}

    String[] removeFromList(String list[], int index) {
		String result[] = null
		for (int pointer = 0; pointer < list.arrayLength; pointer++) {
			if (pointer != index) { result = new String[](result, new String(list[pointer].string)) }
		}
		return result
	}

    char[] getQueryString(char resource[]) {
		String helper[] = stringUtil.explode(resource, "?")
		if (helper.arrayLength == 2) { return new char[](helper[1].string) }
		return ""
	}

    char[] getMIMEType(char resource[]) {
		char fileFormat[] = getFileFormat(resource)
		if (fileFormat == "html" || fileFormat == "htm") { return "text/html" }
		if (fileFormat == "jpg") { return "image/jpeg" }
		if (fileFormat == "png") { return "image/png" }
		if (fileFormat == "gif") { return "image/gif" }
		if (fileFormat == "min.js" || fileFormat == "js") { return "application/x-javascript" }
		if (fileFormat == "css" || fileFormat == "min.css") { return "text/css"	}
		if (fileFormat == "pdf") { return "application/pdf"	}
		if (fileFormat == "mpg") { return "video/mpeg" }
		if (fileFormat == "php") { return fileFormat }
		if (fileFormat == "dn") {return fileFormat }
		return "text/plain"
	}

    char[] getFileFormat(char resource[]) {
		char fileFormat[] = ""
		int i = resource.arrayLength-1
		while (i > 0 && resource[i] != ".") { i-- }
		if (i > 0) { fileFormat = stringUtil.subString(resource, (i+1), (resource.arrayLength-i-1)) }
		return fileFormat
	}

    char[] normalisePath(char resource[]) {
		// in case there is queryString (the GET param)
		String helper[] = stringUtil.explode(resource, "?")
		resource = helper[0].string
		return resource
	}

	char[] getResource(char resource[]) {
		char str[] = clone resource
		int i = 0
		while ((i < str.arrayLength) && (str[i] != "?")) { i++ }
		return new char[](stringUtil.subString(str, 0, i))
	}

    bool resourceExists(char resource[]) {
		if (fileSystem.exists(resource)) {
			if (fileSystem.getInfo(resource).type == FileInfo.TYPE_DIR) { return false } 
			else { return true }
		}
		return false
	}

}