// Main App ProcessLoop Implementation
// This runs continuously in Dana's WASM runtime
// HTTP requests MUST be made from async context, not from loop() directly

uses net.http.Header
uses matmul.Matmul
uses ui.IOLayer
uses ui.Window
uses ui.TextArea
uses ui.Button
uses ui.Label

component provides MainAppLoop requires io.Output out, data.IntUtil iu, 
    data.json.JSONEncoder je, data.json.JSONParser jp, data.StringUtil su,
    net.http.HTTPRequest http, time.Timer timer, ui.IOLayer, ui.Window, 
    ui.TextArea, ui.Button, ui.Label, System system {
    
    const char MATMUL_URL[] = "http://localhost:8080/task"
    const char RESULT_URL_PREFIX[] = "http://localhost:8080/result/"
    const int POLL_INTERVAL_LOOPS = 50 // Approximate loops for 500ms (assuming ~10ms per loop)
    
    // UI Components
    IOLayer coreui
    Window window
    TextArea matrixAInput
    TextArea matrixBInput
    Button submitButton
    Label statusLabel
    Label resultLabel
    
    // State machine: 0=idle, 1=submitting, 2=polling, 3=result received
    int state = 0
    
    // HTTP request state (for async operations)
    HTTPResponse currentResponse = null
    bool waitingForResponse = false
    int currentTaskId = 0
    int requestType = 0 // 0=none, 1=submit, 2=poll
    int loopCount = 0
    int lastPollLoop = 0
    int resultReceivedLoop = 0 // Track when result was received for non-blocking delay
    const int RESULT_DISPLAY_LOOPS = 200 // Approximate loops for 2 seconds (assuming ~10ms per loop)
    
    // UI initialization flag
    bool uiInitialized = false
    bool iolayerInitialized = false
    bool shouldExit = false // Only exit when explicitly requested (e.g., window closed)
    
    MainAppLoop:MainAppLoop() {
        out.println("[@MainAppWASM] Initializing MainAppLoop...")
        // Don't initialize IOLayer here - it might block
        // Initialize it in loop() instead
    }
    
    // This function is called repeatedly by Dana's WASM runtime
    // It MUST NOT block and should return quickly
    bool MainAppLoop:loop() {
        loopCount++
        
        // Initialize IOLayer on first loop (deferred from constructor to avoid blocking)
        if (!iolayerInitialized) {
            out.println("[@MainAppWASM] Initializing IOLayer in loop()...")
            coreui = new IOLayer()
            sinkevent SysEvents(coreui)
            iolayerInitialized = true
            out.println("[@MainAppWASM] IOLayer initialized, waiting for ready event...")
            return true // Return immediately, let next loop process UI
        }
        
        // Process UI events by calling IOLayer's loop
        // This must be called regularly for events to be processed
        // In WASM, loop() may return true during startup, but we should continue running
        // We only exit when shouldExit is explicitly set (e.g., window closed event)
        if (coreui != null) {
            coreui.loop() // Call loop() to process events, but ignore return value
            // We'll exit based on shouldExit flag set by events, not loop() return value
        } else {
            out.println("[@MainAppWASM] WARNING: coreui is null!")
        }
        
        // Check if we should exit (set by window close event)
        if (shouldExit) {
            out.println("[@MainAppWASM] Exiting ProcessLoop")
            return false
        }
        
        // Debug: Try to initialize UI after a few loops if not already initialized
        // This is a fallback in case the ready event doesn't fire
        if (!uiInitialized && loopCount > 10 && coreui != null) {
            out.println("[@MainAppWASM] Fallback: Initializing UI after loop delay (loopCount=$(iu.makeString(loopCount)))")
            initializeUI()
            // uiInitialized is now set inside initializeUI()
        }
        
        // Debug output every 50 loops to see if we're still running
        if (loopCount % 50 == 0) {
            char uiInitStr[]
            if (uiInitialized)
                uiInitStr = "true"
                else
                uiInitStr = "false"
            char ioInitStr[]
            if (iolayerInitialized)
                ioInitStr = "true"
                else
                ioInitStr = "false"
            out.println("[@MainAppWASM] Loop running: loopCount=$(iu.makeString(loopCount)), iolayerInitialized=$ioInitStr, uiInitialized=$uiInitStr")
        }
        
        // Check if we're waiting for an HTTP response
        if (waitingForResponse) {
            if (currentResponse != null) {
                // In WASM, HTTP responses might not have responseCode populated
                // But we should still handle the response to check for content
                // handleResponse() will handle the missing responseCode case
                handleResponse()
                waitingForResponse = false
                currentResponse = null
            }
            // Still waiting, return true to continue loop
            return true
        }
        
        // If we're in polling state, check if it's time to poll
        if (state == 2) {
            if (loopCount - lastPollLoop >= POLL_INTERVAL_LOOPS) {
                lastPollLoop = loopCount
                startPollRequest()
            }
        }
        
        // If we're in result received state, check if it's time to reset to idle
        if (state == 3) {
            if (loopCount - resultReceivedLoop >= RESULT_DISPLAY_LOOPS) {
                state = 0
                statusLabel.setText("Ready")
                submitButton.setDisabled(false)
            }
        }
        
        // Continue running
        return true
    }
    
    void initializeUI() {
        out.println("[@MainAppWASM] Initializing UI...")
        
        // Create main window
        window = new Window("Matrix Multiplication - Dana WASM")
        out.println("[@MainAppWASM] Window created")
        window.setSize(800, 600)
        out.println("[@MainAppWASM] Window size set to 800x600")
        window.setVisible(true)
        out.println("[@MainAppWASM] Window set to visible")
        
        // Mark UI as initialized BEFORE adding objects (so loop() doesn't exit prematurely)
        uiInitialized = true
        
        // Create matrix A input
        matrixAInput = new TextArea()
        matrixAInput.setPosition(20, 50)
        matrixAInput.setSize(350, 200)
        matrixAInput.setText("[[1,2],[3,4]]")
        window.addObject(matrixAInput)
        
        // Create matrix B input
        matrixBInput = new TextArea()
        matrixBInput.setPosition(430, 50)
        matrixBInput.setSize(350, 200)
        matrixBInput.setText("[[5,6],[7,8]]")
        window.addObject(matrixBInput)
        
        // Create submit button
        submitButton = new Button("Submit")
        submitButton.setPosition(350, 270)
        window.addObject(submitButton)
        
        // Create status label
        statusLabel = new Label("Ready")
        statusLabel.setPosition(20, 320)
        window.addObject(statusLabel)
        
        // Create result label
        resultLabel = new Label("Result will appear here...")
        resultLabel.setPosition(20, 360)
        window.addObject(resultLabel)
        
        // Subscribe to events
        sinkevent AppEvents(submitButton)
        sinkevent SysEvents(window)
        sinkevent SysEvents(coreui)
        
        out.println("[@MainAppWASM] UI initialized - window and controls created")
    }
    
    eventsink AppEvents(EventData ed) {
        if (ed.type == Button.[click] && ed.source === submitButton) {
            if (state == 0) {
                // User clicked submit - start submission
                startSubmitRequest()
            }
        }
    }
    
    eventsink SysEvents(EventData ed) {
        if (ed.source === coreui && ed.type == IOLayer.[ready]) {
            out.println("[@MainAppWASM] IOLayer ready event received!")
            if (!uiInitialized) {
                initializeUI()
                // uiInitialized is now set inside initializeUI()
            }
        } else if (ed.source === window && ed.type == Window.[close]) {
            out.println("[@MainAppWASM] Window closed - setting exit flag")
            shouldExit = true
            if (window != null) {
                window.close()
            }
            if (coreui != null) {
                coreui.shutdown()
            }
        }
    }
    
    void startSubmitRequest() {
        if (waitingForResponse || state != 0) return // Already have a request in flight or not idle
        
        out.println("[@MainAppWASM] Starting submit request...")
        
        // Get matrix inputs from TextArea (getText() returns char[])
        char matrixAText[] = matrixAInput.getText()
        char matrixBText[] = matrixBInput.getText()
        
        if (matrixAText == null || matrixAText.arrayLength == 0 ||
            matrixBText == null || matrixBText.arrayLength == 0) {
            statusLabel.setText("Error: Please enter both matrices")
            return
        }
        
        // Build JSON request body - server expects {A: "...", B: "..."}
        // where A and B are JSON strings (e.g., "[[1,2],[3,4]]")
        MultiplyParamsFormat requestData = new MultiplyParamsFormat(matrixAText, matrixBText)
        char jsonBody[] = je.jsonFromData(requestData)
        
        // Build headers
        Header headers[] = new Header[](
            new Header("Content-Type", "application/json")
        )
        
        // Update state and UI
        state = 1 // submitting
        statusLabel.setText("Submitting task...")
        submitButton.setDisabled(true)
        
        // Start async request
        requestType = 1 // submit request
        waitingForResponse = true
        
        // Execute HTTP request in async context
        asynch::executeSubmitRequest(MATMUL_URL, headers, jsonBody)
    }
    
    void executeSubmitRequest(char url[], Header headers[], char postData[]) {
        // This runs in async context, allowing HTTP requests in WASM
        // http.post() must be called from async context, not from ProcessLoop:loop()
        currentResponse = http.post(url, headers, postData, false)
    }
    
    void startPollRequest() {
        if (waitingForResponse || state != 2) return // Already have a request in flight or not polling
        
        out.println("[@MainAppWASM] Polling for result for task #$(iu.makeString(currentTaskId))...")
        
        // Build poll URL
        char pollUrl[] = new char[](RESULT_URL_PREFIX, iu.makeString(currentTaskId))
        
        // Build headers
        Header headers[] = new Header[](
            new Header("Content-Type", "application/json")
        )
        
        // Start async request
        requestType = 2 // poll request
        waitingForResponse = true
        
        // Execute HTTP request in async context
        asynch::executePollRequest(pollUrl, headers)
    }
    
    void executePollRequest(char url[], Header headers[]) {
        // This runs in async context, allowing HTTP requests in WASM
        // http.get() must be called from async context, not from ProcessLoop:loop()
        out.println("[@MainAppWASM] Executing HTTP GET request to: $(url)")
        currentResponse = http.get(url, headers, false)
        if (currentResponse == null) {
            out.println("[@MainAppWASM] HTTP GET returned null response")
        } else {
            // Debug: Print all response fields to understand what we're getting
            if (currentResponse.responseCode == null || currentResponse.responseCode.arrayLength == 0) {
                out.println("[@MainAppWASM] HTTP GET returned response with no responseCode")
                if (currentResponse.responseMessage != null) {
                    out.println("[@MainAppWASM] Response message: $(currentResponse.responseMessage)")
                }
                if (currentResponse.content != null) {
                    out.println("[@MainAppWASM] Response has content, length: $(iu.makeString(currentResponse.content.arrayLength))")
                }
                if (currentResponse.url != null) {
                    out.println("[@MainAppWASM] Response URL: $(currentResponse.url)")
                }
            } else {
                out.println("[@MainAppWASM] HTTP GET returned response code: $(currentResponse.responseCode)")
            }
        }
    }
    
    void handleResponse() {
        if (currentResponse == null) {
            out.println("[@MainAppWASM] No response received")
            state = 0
            statusLabel.setText("Error: No response from server")
            submitButton.setDisabled(true)
            return
        }
        
        if (requestType == 1) {
            // Handle submit response
            handleSubmitResponse()
        } else if (requestType == 2) {
            // Handle poll response
            handlePollResponse()
        }
        
        requestType = 0
    }
    
    void handleSubmitResponse() {
        if (currentResponse.responseCode != "200") {
            out.println("[@MainAppWASM] Submit failed with code: $(currentResponse.responseCode)")
            state = 0
            char errorMsg[] = new char[]("Error: Submit failed (", currentResponse.responseCode, ")")
            statusLabel.setText(errorMsg)
            submitButton.setDisabled(true)
            return
        }
        
        // Convert byte[] content to char[] for JSON parsing
        if (currentResponse.content == null || currentResponse.content.arrayLength == 0) {
            out.println("[@MainAppWASM] Empty response body from submit")
            state = 0
            statusLabel.setText("Error: Empty response")
            submitButton.setDisabled(true)
            return
        }
        
        char responseBody[] = new char[currentResponse.content.arrayLength]
        for (int i = 0; i < currentResponse.content.arrayLength; i++) {
            responseBody[i] = currentResponse.content[i]
        }
        
        // Parse JSON response - server returns {taskId: 1}
        JSONElement root = jp.parseDocument(responseBody)
        if (root == null) {
            out.println("[@MainAppWASM] Failed to parse submit response")
            state = 0
            statusLabel.setText("Error: Failed to parse response")
            submitButton.setDisabled(true)
            return
        }
        
        // Extract taskId
        JSONElement taskIdElem = jp.getValue(root, "taskId")
        if (taskIdElem == null || taskIdElem.type != JSONElement.TYPE_NUMBER) {
            out.println("[@MainAppWASM] Missing or invalid taskId in response")
            state = 0
            statusLabel.setText("Error: Invalid response format")
            submitButton.setDisabled(true)
            return
        }
        
        currentTaskId = iu.intFromString(taskIdElem.value)
        out.println("[@MainAppWASM] Task submitted successfully, taskId: $(iu.makeString(currentTaskId))")
        
        // Switch to polling state
        state = 2 // polling
        char statusMsg[] = new char[]("Task submitted (ID: ", iu.makeString(currentTaskId), "). Polling for result...")
        statusLabel.setText(statusMsg)
        lastPollLoop = loopCount
    }
    
    void handlePollResponse() {
        // Check if response is null
        if (currentResponse == null) {
            out.println("[@MainAppWASM] Poll response is null, will retry polling...")
            // Don't reset state - continue polling
            return
        }
        
        // Check if responseCode is null or empty - this might be a WASM HTTP issue
        // Try to infer status from content or other fields
        if (currentResponse.responseCode == null || currentResponse.responseCode.arrayLength == 0) {
            // In WASM, HTTP responses might not populate responseCode correctly
            // Check if we have content - if yes, assume 200 OK and process it
            if (currentResponse.content != null && currentResponse.content.arrayLength > 0) {
                out.println("[@MainAppWASM] Response has content but no responseCode - assuming 200 OK, processing result")
                // Treat as 200 OK and continue processing
                // We'll set a dummy responseCode for processing
                currentResponse.responseCode = "200"
                // Fall through to process the content
            } else {
                // No content and no responseCode - likely 204 No Content (not ready)
                out.println("[@MainAppWASM] No content and no responseCode - assuming 204 (not ready), will continue polling")
                // Don't reset state - continue polling by returning early
                // The loop will call startPollRequest() again after POLL_INTERVAL_LOOPS
                return
            }
        }
        
        // Handle 204 (No Content) and 404 (Not Found) - these mean "not ready yet"
        if (currentResponse.responseCode == "204" || currentResponse.responseCode == "404") {
            // No result yet or not found - keep polling
            out.println("[@MainAppWASM] Result not ready yet (code: $(currentResponse.responseCode)), continuing to poll...")
            return
        }
        
        // Handle non-200 responses
        if (currentResponse.responseCode != "200") {
            out.println("[@MainAppWASM] Poll failed with code: $(currentResponse.responseCode)")
            state = 0
            char errorMsg[] = new char[]("Error: Poll failed (", currentResponse.responseCode, ")")
            statusLabel.setText(errorMsg)
            submitButton.setDisabled(true)
            return
        }
        
        // Convert byte[] content to char[] for JSON parsing
        if (currentResponse.content == null || currentResponse.content.arrayLength == 0) {
            out.println("[@MainAppWASM] Empty response body from poll")
            // Continue polling
            return
        }
        
        // Safely convert byte[] to char[]
        char responseBody[] = null
        if (currentResponse.content != null && currentResponse.content.arrayLength > 0) {
            responseBody = new char[currentResponse.content.arrayLength]
            for (int i = 0; i < currentResponse.content.arrayLength; i++) {
                responseBody[i] = currentResponse.content[i]
            }
        }
        
        // Validate response body before parsing
        if (responseBody == null || responseBody.arrayLength == 0) {
            out.println("[@MainAppWASM] Invalid response body, continuing to poll...")
            return
        }
        
        // Parse JSON response - server returns {taskId, status, result}
        // Use defensive parsing with null checks
        // Note: Dana exceptions are advisory, so parseDocument may throw but still return a value
        JSONElement root = jp.parseDocument(responseBody)
        
        if (root == null) {
            out.println("[@MainAppWASM] Failed to parse poll response or empty response body")
            // Continue polling
            return
        }
        
        // If parsing succeeded but we got exceptions (advisory), the root might still be valid
        // Continue processing - the exception is just a warning
        
        // Check status field first (defensive)
        JSONElement statusElem = null
        if (root != null) {
            statusElem = jp.getValue(root, "status")
        }
        
        if (statusElem != null && statusElem.type == JSONElement.TYPE_STRING && statusElem.value != null) {
            char status[] = statusElem.value
            if (status == "pending" || status == "processing") {
                // Task not ready yet - continue polling
                out.println("[@MainAppWASM] Task status: $(status), continuing to poll...")
                return
            }
        }
        
        // Extract result field (defensive)
        JSONElement resultElem = null
        if (root != null) {
            resultElem = jp.getValue(root, "result")
        }
        
        if (resultElem == null) {
            out.println("[@MainAppWASM] No result field in response, continuing to poll...")
            return
        }
        
        // Check if result is empty or null (defensive type checking)
        char resultText[] = null
        if (resultElem.type == JSONElement.TYPE_STRING) {
            if (resultElem.value != null) {
                resultText = resultElem.value
                if (resultText.arrayLength == 0 || resultText == "\"\"") {
                    out.println("[@MainAppWASM] Result is empty, continuing to poll...")
                    return
                }
                // Result is a JSON string containing the matrix (e.g., "[[19,22],[43,50]]")
                // Use it directly - it's already in the correct format
            } else {
                out.println("[@MainAppWASM] Result value is null, continuing to poll...")
                return
            }
        } else if (resultElem.type == JSONElement.TYPE_OBJECT) {
            // Result is a nested object (e.g., {"result":"..."}) - extract inner result
            JSONElement innerResult = jp.getValue(resultElem, "result")
            if (innerResult != null && innerResult.type == JSONElement.TYPE_STRING && innerResult.value != null) {
                resultText = innerResult.value
            } else {
                out.println("[@MainAppWASM] Nested result object has unexpected format, continuing to poll...")
                return
            }
        } else if (resultElem.type == JSONElement.TYPE_ARRAY) {
            // Result is a JSON array - convert to string
            if (resultElem != null) {
                resultText = je.jsonFromData(resultElem)
            }
        } else {
            out.println("[@MainAppWASM] Result has unexpected type: $(iu.makeString(resultElem.type)), continuing to poll...")
            return
        }
        
        // Final check - make sure we have a valid result
        if (resultText == null || resultText.arrayLength == 0) {
            out.println("[@MainAppWASM] Result text is null or empty, continuing to poll...")
            return
        }
        
        // Display result
        char resultDisplay[] = new char[]("Result: ", resultText)
        resultLabel.setText(resultDisplay)
        statusLabel.setText("Computation complete!")
        
        out.println("[@MainAppWASM] Result received: $(resultText)")
        
        // Set to result received state - will reset to idle after delay (non-blocking)
        state = 3 // result received
        resultReceivedLoop = loopCount // Track when result was received
        submitButton.setDisabled(true)
    }
}

