// Main App ProcessLoop Implementation
// This runs continuously in Dana's WASM runtime
// HTTP requests MUST be made from async context, not from loop() directly

uses net.http.Header
uses matmul.MultiplyParamsFormat

component provides MainAppLoop requires io.Output out, data.IntUtil iu, 
    data.json.JSONEncoder je, data.json.JSONParser jp, data.StringUtil su,
    net.http.HTTPRequest http, time.Timer timer, ui.IOLayer, ui.Window, 
    ui.TextArea, ui.Button, ui.Label, System system {
    
    const char MATMUL_URL[] = "http://localhost:8080/task"
    const char RESULT_URL_PREFIX[] = "http://localhost:8080/result/"
    const int POLL_INTERVAL_LOOPS = 50 // Approximate loops for 500ms (assuming ~10ms per loop)
    
    // UI Components
    IOLayer coreui
    Window window
    TextArea matrixAInput
    TextArea matrixBInput
    Button submitButton
    Label statusLabel
    Label resultLabel
    
    // State machine: 0=idle, 1=submitting, 2=polling, 3=result received
    int state = 0
    
    // HTTP request state (for async operations)
    HTTPResponse currentResponse = null
    bool waitingForResponse = false
    int currentTaskId = 0
    int requestType = 0 // 0=none, 1=submit, 2=poll
    int loopCount = 0
    int lastPollLoop = 0
    
    // UI initialization flag
    bool uiInitialized = false
    
    MainAppLoop:MainAppLoop() {
        out.println("[@MainAppWASM] Initializing MainAppLoop...")
        
        // Initialize IOLayer
        coreui = new IOLayer()
        
        // Listen for IOLayer ready event
        sinkevent SysEvents(coreui)
    }
    
    // This function is called repeatedly by Dana's WASM runtime
    // It MUST NOT block and should return quickly
    bool MainAppLoop:loop() {
        loopCount++
        
        // Process UI events by calling IOLayer's loop
        if (coreui != null) {
            bool uiDone = coreui.loop()
            if (uiDone) {
                // IOLayer wants to exit
                return false
            }
        }
        
        // Check if we're waiting for an HTTP response
        if (waitingForResponse) {
            if (currentResponse != null) {
                handleResponse()
                waitingForResponse = false
                currentResponse = null
            }
            // Still waiting, return true to continue loop
            return true
        }
        
        // If we're in polling state, check if it's time to poll
        if (state == 2) {
            if (loopCount - lastPollLoop >= POLL_INTERVAL_LOOPS) {
                lastPollLoop = loopCount
                startPollRequest()
            }
        }
        
        // Continue running
        return true
    }
    
    void initializeUI() {
        out.println("[@MainAppWASM] Initializing UI...")
        
        // Create main window
        window = new Window("Matrix Multiplication - Dana WASM")
        window.setSize(800, 600)
        window.setVisible(true)
        
        // Create matrix A input
        matrixAInput = new TextArea()
        matrixAInput.setPosition(20, 50)
        matrixAInput.setSize(350, 200)
        matrixAInput.setText("[[1,2],[3,4]]")
        window.addObject(matrixAInput)
        
        // Create matrix B input
        matrixBInput = new TextArea()
        matrixBInput.setPosition(430, 50)
        matrixBInput.setSize(350, 200)
        matrixBInput.setText("[[5,6],[7,8]]")
        window.addObject(matrixBInput)
        
        // Create submit button
        submitButton = new Button("Submit")
        submitButton.setPosition(350, 270)
        submitButton.setSize(100, 30)
        window.addObject(submitButton)
        
        // Create status label
        statusLabel = new Label("Ready")
        statusLabel.setPosition(20, 320)
        statusLabel.setSize(760, 30)
        window.addObject(statusLabel)
        
        // Create result label
        resultLabel = new Label("Result will appear here...")
        resultLabel.setPosition(20, 360)
        resultLabel.setSize(760, 200)
        window.addObject(resultLabel)
        
        // Subscribe to events
        sinkevent AppEvents(submitButton)
        sinkevent SysEvents(window)
        sinkevent SysEvents(coreui)
        
        out.println("[@MainAppWASM] UI initialized")
    }
    
    eventsink AppEvents(EventData ed) {
        if (ed.type == Button.[click] && ed.source === submitButton) {
            if (state == 0) {
                // User clicked submit - start submission
                startSubmitRequest()
            }
        }
    }
    
    eventsink SysEvents(EventData ed) {
        if (ed.source === coreui && ed.type == IOLayer.[ready]) {
            out.println("[@MainAppWASM] IOLayer ready")
            if (!uiInitialized) {
                initializeUI()
                uiInitialized = true
            }
        } else if (ed.source === window && ed.type == Window.[close]) {
            out.println("[@MainAppWASM] Window closed")
            if (window != null) {
                window.close()
            }
            if (coreui != null) {
                coreui.shutdown()
            }
        }
    }
    
    void startSubmitRequest() {
        if (waitingForResponse || state != 0) return // Already have a request in flight or not idle
        
        out.println("[@MainAppWASM] Starting submit request...")
        
        // Get matrix inputs from TextArea (getText() returns char[])
        char matrixAText[] = matrixAInput.getText()
        char matrixBText[] = matrixBInput.getText()
        
        if (matrixAText == null || matrixAText.arrayLength == 0 ||
            matrixBText == null || matrixBText.arrayLength == 0) {
            statusLabel.setText("Error: Please enter both matrices")
            return
        }
        
        // Build JSON request body - server expects {A: "...", B: "..."}
        // where A and B are JSON strings (e.g., "[[1,2],[3,4]]")
        MultiplyParamsFormat requestData = new MultiplyParamsFormat(matrixAText, matrixBText)
        char jsonBody[] = je.jsonFromData(requestData)
        
        // Build headers
        Header headers[] = new Header[](
            new Header("Content-Type", "application/json")
        )
        
        // Update state and UI
        state = 1 // submitting
        statusLabel.setText("Submitting task...")
        submitButton.setEnabled(false)
        
        // Start async request
        requestType = 1 // submit request
        waitingForResponse = true
        
        // Execute HTTP request in async context
        asynch::executeSubmitRequest(MATMUL_URL, headers, jsonBody)
    }
    
    void executeSubmitRequest(char url[], Header headers[], char postData[]) {
        // This runs in async context, allowing HTTP requests in WASM
        // http.post() must be called from async context, not from ProcessLoop:loop()
        currentResponse = http.post(url, headers, postData, false)
    }
    
    void startPollRequest() {
        if (waitingForResponse || state != 2) return // Already have a request in flight or not polling
        
        out.println("[@MainAppWASM] Polling for result for task #$(iu.makeString(currentTaskId))...")
        
        // Build poll URL
        char pollUrl[] = new char[](RESULT_URL_PREFIX, iu.makeString(currentTaskId))
        
        // Build headers
        Header headers[] = new Header[](
            new Header("Content-Type", "application/json")
        )
        
        // Start async request
        requestType = 2 // poll request
        waitingForResponse = true
        
        // Execute HTTP request in async context
        asynch::executePollRequest(pollUrl, headers)
    }
    
    void executePollRequest(char url[], Header headers[]) {
        // This runs in async context, allowing HTTP requests in WASM
        // http.get() must be called from async context, not from ProcessLoop:loop()
        currentResponse = http.get(url, headers, false)
    }
    
    void handleResponse() {
        if (currentResponse == null) {
            out.println("[@MainAppWASM] No response received")
            state = 0
            statusLabel.setText("Error: No response from server")
            submitButton.setEnabled(true)
            return
        }
        
        if (requestType == 1) {
            // Handle submit response
            handleSubmitResponse()
        } else if (requestType == 2) {
            // Handle poll response
            handlePollResponse()
        }
        
        requestType = 0
    }
    
    void handleSubmitResponse() {
        if (currentResponse.responseCode != "200") {
            out.println("[@MainAppWASM] Submit failed with code: $(currentResponse.responseCode)")
            state = 0
            char errorMsg[] = new char[]("Error: Submit failed (", currentResponse.responseCode, ")")
            statusLabel.setText(errorMsg)
            submitButton.setEnabled(true)
            return
        }
        
        // Convert byte[] content to char[] for JSON parsing
        if (currentResponse.content == null || currentResponse.content.arrayLength == 0) {
            out.println("[@MainAppWASM] Empty response body from submit")
            state = 0
            statusLabel.setText("Error: Empty response")
            submitButton.setEnabled(true)
            return
        }
        
        char responseBody[] = new char[currentResponse.content.arrayLength]
        for (int i = 0; i < currentResponse.content.arrayLength; i++) {
            responseBody[i] = currentResponse.content[i]
        }
        
        // Parse JSON response - server returns {taskId: 1}
        JSONElement root = jp.parseDocument(responseBody)
        if (root == null) {
            out.println("[@MainAppWASM] Failed to parse submit response")
            state = 0
            statusLabel.setText("Error: Failed to parse response")
            submitButton.setEnabled(true)
            return
        }
        
        // Extract taskId
        JSONElement taskIdElem = jp.getValue(root, "taskId")
        if (taskIdElem == null || taskIdElem.type != JSONElement.TYPE_NUMBER) {
            out.println("[@MainAppWASM] Missing or invalid taskId in response")
            state = 0
            statusLabel.setText("Error: Invalid response format")
            submitButton.setEnabled(true)
            return
        }
        
        currentTaskId = iu.intFromString(taskIdElem.value)
        out.println("[@MainAppWASM] Task submitted successfully, taskId: $(iu.makeString(currentTaskId))")
        
        // Switch to polling state
        state = 2 // polling
        char statusMsg[] = new char[]("Task submitted (ID: ", iu.makeString(currentTaskId), "). Polling for result...")
        statusLabel.setText(statusMsg)
        lastPollLoop = loopCount
    }
    
    void handlePollResponse() {
        if (currentResponse.responseCode == "204" || currentResponse.responseCode == "404") {
            // No result yet or not found - keep polling
            out.println("[@MainAppWASM] Result not ready yet, continuing to poll...")
            return
        }
        
        if (currentResponse.responseCode != "200") {
            out.println("[@MainAppWASM] Poll failed with code: $(currentResponse.responseCode)")
            state = 0
            char errorMsg[] = new char[]("Error: Poll failed (", currentResponse.responseCode, ")")
            statusLabel.setText(errorMsg)
            submitButton.setEnabled(true)
            return
        }
        
        // Convert byte[] content to char[] for JSON parsing
        if (currentResponse.content == null || currentResponse.content.arrayLength == 0) {
            out.println("[@MainAppWASM] Empty response body from poll")
            // Continue polling
            return
        }
        
        char responseBody[] = new char[currentResponse.content.arrayLength]
        for (int i = 0; i < currentResponse.content.arrayLength; i++) {
            responseBody[i] = currentResponse.content[i]
        }
        
        // Parse JSON response - server returns the result matrix
        // The result is a JSON array (e.g., [[19,22],[43,50]])
        JSONElement root = jp.parseDocument(responseBody)
        if (root == null) {
            out.println("[@MainAppWASM] Failed to parse poll response")
            // Continue polling
            return
        }
        
        // Display result
        char resultText[] = responseBody
        char resultDisplay[] = new char[]("Result: ", resultText)
        resultLabel.setText(resultDisplay)
        statusLabel.setText("Computation complete!")
        
        out.println("[@MainAppWASM] Result received: $(resultText)")
        
        // Reset to idle state
        state = 3 // result received
        submitButton.setEnabled(true)
        
        // After displaying result, reset to idle after a short delay
        timer.sleep(2000)
        state = 0
        statusLabel.setText("Ready")
    }
}

