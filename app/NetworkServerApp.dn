uses server.Server
uses network.http.HTTPUtil

component provides App requires data.IntUtil iu, io.Output out, server.Server server,
    network.http.HTTPUtil httpUtil, net.TCPServerSocket, net.TCPSocket {
    
    const char debugMSG[] = "[@NetworkServerApp]"
    const int DEFAULT_PORT = 2010
    
    int App:main(AppParam params[]) {
        // First parameter: mode (1=proxy, 2=adaptive, 3=local)
        // Second parameter: port (optional, default 2010)
        int mode = Server.MODE_LOCAL
        int port = DEFAULT_PORT
        
        if (params.arrayLength > 0) {
            int providedMode = iu.intFromString(params[0].string)
            if (providedMode == Server.MODE_PROXY || providedMode == Server.MODE_ADAPTIVE || providedMode == Server.MODE_LOCAL) {
                mode = providedMode
            }
        }
        
        if (params.arrayLength > 1) {
            port = iu.intFromString(params[1].string)
        }
        
        // Initialize server with mode
        server.initialize(mode)
        
        out.println("")
        out.println("========================================")
        out.println("  Dana Web Server (Pure Dana Backend)")
        out.println("========================================")
        out.println("Server running at http://localhost:$(iu.makeString(port))")
        out.println("Open: http://localhost:$(iu.makeString(port))/xdana.html")
        out.println("")
        out.println("Endpoints:")
        out.println("  - /matmul          (Matrix multiplication)")
        out.println("  - /task            (Submit tasks)")
        out.println("  - /task/next       (Get next task)")
        out.println("  - /result/:id      (Get result)")
        out.println("  - /stats           (Queue statistics)")
        out.println("  - /*               (Static files)")
        out.println("========================================")
        out.println("")
        
        // Bind to TCP port
        TCPServerSocket host = new TCPServerSocket()
        if (!host.bind(TCPServerSocket.ANY_ADDRESS, port)) {
            out.println("$debugMSG - Error: failed to bind to port $(iu.makeString(port))")
            return 1
        }
        
        out.println("$debugMSG - HTTP server listening on port $(iu.makeString(port))")
        
        // Main request loop
        while (true) {
            TCPSocket client = new TCPSocket()
            if (client.accept(host)) {
                asynch::handleHTTPRequest(client)
            }
        }
        
        return 0
    }
    
    void handleHTTPRequest(TCPSocket client) {
        out.println("$debugMSG - New connection accepted, reading request...")
        
        // Read request from socket
        char request[] = client.recv(8192)
        
        if (request == null || request.arrayLength == 0) {
            out.println("$debugMSG - Warning: received empty request")
            client.disconnect()
            return
        }
        
        out.println("$debugMSG - Received $(iu.makeString(request.arrayLength)) bytes")
        
        // Process through server
        char response[] = server.handleRequest(request)
        
        if (response == null || response.arrayLength == 0) {
            out.println("$debugMSG - Warning: server returned empty response")
            client.disconnect()
            return
        }
        
        out.println("$debugMSG - Sending response ($(iu.makeString(response.arrayLength)) bytes)")
        
        // Send response back
        int sent = client.send(response)
        out.println("$debugMSG - Sent $(iu.makeString(sent)) bytes")
        
        // Flush any buffered data
        if (client.connected()) {
            int unsent = client.getBufferUnsent()
            if (unsent > 0) {
                out.println("$debugMSG - Flushing $(iu.makeString(unsent)) unsent bytes")
                client.sendBuffer()
            }
        }
        
        client.disconnect()
        out.println("$debugMSG - Connection closed")
    }
}

